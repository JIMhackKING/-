C51 COMPILER V9.59.0.0   CLOCK                                                             05/30/2019 00:26:05 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE CLOCK
OBJECT MODULE PLACED IN .\Objects\Clock.obj
COMPILER INVOKED BY: D:\KEIL_C51\C51\BIN\C51.EXE code\Clock.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listin
                    -gs\Clock.lst) TABS(2) OBJECT(.\Objects\Clock.obj)

line level    source

   1          /************************************************
   2          功能介绍：带闹钟功能的定时浇花装置
   3          端口：
   4            P0  -->  数码管段位显示
   5            P2.0 ~ P2.3  -->  数码管位码
   6            P2.5  -->  蜂鸣器（闹钟响起时为低电平)
   7            P3.2 ~ P3.5  -->  按钮开关
   8          *************************************************/
   9          
  10          #include <stdio.h>
  11          #include "SystemFunc.h"
  12          #include "eeprom.h"
  13          
  14          /************************************************
  15          常量定义
  16          ************************************************/
  17          uint count=0;  // 计数总值
  18          uchar Dis_code[]
  19          ={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};
  20          uchar dis_buff[4];  //数码管显示的所有数字
  21          uchar MODE=0;  // 模式选择，设置闹钟
  22          uint clock[3]={0,1,2};  // 第一个实时时间，2个闹钟设置，第三个时浇花时长
  23          bit Clock_Status=0;  // 闹钟开关标志
  24          bit is_open = 0;  // 闹钟已经响起的标志位
  25          uint this_time;  // 闹钟时间已经到达，防止关闭闹钟但时间还是在闹钟时间的时候重复响闹钟
  26          
  27          // buzzer
  28          sbit output=P2^5;
  29          // buzzer control button
  30          sbit KEY_CONTROL = P3^3;
  31          // clock status led
  32          sbit status_led = P1^7;
  33          /************************************************/
  34          
  35          /*
  36          外部中断1响应函数
  37          闹钟控制按钮，闹钟没响时控制闹钟开关，闹钟已经响起时关闭闹钟
  38          */
  39          void EXT1(void) interrupt 2
  40          {
  41   1        Delay(2);
  42   1        if(KEY_CONTROL == 0)  // 延时消抖
  43   1        {
  44   2          if (is_open)  // 如果闹钟已经响了
  45   2          {
  46   3            output = 1;  // 关闭闹钟
  47   3            is_open = 0;  // 清除标志位
  48   3          }
  49   2          else  // 如果闹钟没响
  50   2          {
  51   3            Clock_Status=!Clock_Status;  // 关闭闹钟开关
  52   3            status_led = !Clock_Status; 
  53   3          }
  54   2        }
C51 COMPILER V9.59.0.0   CLOCK                                                             05/30/2019 00:26:05 PAGE 2   

  55   1      }
  56          
  57          /************************************************
  58          作用：定时器0中断函数，定时时间为分
  59          ************************************************/
  60          void TC0(void) interrupt 1
  61          {
  62   1        // 11.0592MHz 晶振频率 50ms 计数值为 46080
  63   1        TH0=TH0+0x4c;  // 初始化初值
  64   1        TL0=TL0+0x00;
  65   1        count++;
  66   1        if(count==1200)  // 1m
  67   1        {
  68   2          count=0;
  69   2          clock[0]++;
  70   2          if(clock[0]==1440)
  71   2            clock[0]=0;
  72   2        }
  73   1      }
  74          
  75          // 检查时间是否到了闹钟时间
  76          void check_clock(void)
  77          {
  78   1        uchar j;
  79   1        for(j=1;j<3;j++)  // 轮流检查两个闹钟时间
  80   1        {
  81   2            if((clock[0] == clock[j]) && clock[0] != this_time)  // 当前时间是否已经到了设定的闹钟时间
  82   2            {
  83   3              output=0;  // 开启蜂鸣器
  84   3              is_open = 1;  // 设置标志位
  85   3              this_time = clock[0];
  86   3            }
  87   2        }
  88   1      }
  89          
  90          void main(void)
  91          {
  92   1        // 程序开始时先从的eeprom加载设置的闹钟时间
  93   1        clock[1] = eeprom_read_byte(0x2800) | ((uint)eeprom_read_byte(0x2801) << 8);
  94   1        clock[2] = eeprom_read_byte(0x2802) | ((uint)eeprom_read_byte(0x2803) << 8);
  95   1        INT_Init();  // 中断初始化
  96   1        PT0=1;  // 设置定时器0为最高优先级
  97   1        P1 &= 0xfe;  // Init the start led status
  98   1        output = 1;
  99   1        while(1)
 100   1        {
 101   2          Bin2Bcd(clock[MODE]);  // 数码管编码
 102   2          display();  // 数码管显示
 103   2          //deal_cmd();
 104   2          key_press();  // 检查按键是否按下
 105   2          if(Clock_Status==0) continue;  // 如果闹钟被关闭就不执行下面的语句
 106   2          check_clock();
 107   2        }
 108   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    303    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     25    ----
C51 COMPILER V9.59.0.0   CLOCK                                                             05/30/2019 00:26:05 PAGE 3   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
